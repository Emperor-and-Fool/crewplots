What that screenshot tells us
Cookie name	Domain that owns it	Who probably set it	Will it be sent on every request to your repl?
connect.sid	replit.com (parent domain)	The very first session() middleware you mounted – its default is to let the browser decide the domain, so Chrome stored it as a “host-only” cookie the first time you hit the https://replit.com origin (when the repl proxy showed the login form).	Yes – because *.replit.com covers your container sub-domain too.
connect.sid-refreshed	136c4c4b-….repl.co (your container’s host)	A second call to session() (or custom res.cookie(...)) that happened after you were already on the sub-domain.	Yes – because an exact-host cookie is also sent.

Both cookies travel in the same header:

Cookie: connect.sid=<JWT-looking-value>; connect.sid-refreshed=<53-char-id>;

Express-session stops at the first match, so whichever cookie appears first in the string becomes the “real” session ID.
When that SID is not found in the store (or is expired) Passport treats the request as unauthenticated → React loops back to /login.

That’s the “competing session IDs” you’re seeing.
Why it suddenly broke after the timing changes

Before you cleared the sessions, both SIDs existed in your session store, so even if Express read the wrong one, it still resolved to a user and you reached the portal page.
When you flushed the store, the orphaned cookie (connect.sid from replit.com) no longer matched a record; Express now creates a fresh SID, but your client still sends the stale one first → perpetual 401/redirect loop.
Fix it once, fix it everywhere
1 · Mount one session() middleware

// server/index.ts (or app.js)
import session from 'express-session';
import MongoStore from 'connect-mongo';

app.use(session({
  // stick to ONE cookie name
  name: 'connect.sid',

  secret: process.env.SESSION_SECRET,
  store: MongoStore.create({ mongoUrl: process.env.MONGO_URI }),
  resave: false,
  saveUninitialized: false,

  cookie: {
    // let the browser create a *host-only* cookie
    // remove `domain:` entirely so you never write to the parent domain
    path: '/',          // keep it stable
    sameSite: 'lax',    // your SPA + API are same-origin on Replit
    secure: true,       // Replit is HTTPS
    httpOnly: true,
  },
}));

    Do not call session() again inside an /api router or in an auth sub-router.

    Delete any custom res.cookie('connect.sid-refreshed', …) code – you don’t need manual rotation; rolling: true in express-session will update the single cookie for you if required.

2 · Blow away all rogue cookies in the browser once

DevTools → Application → Storage → “Clear site data” (or manually delete both rows).
Next login should create exactly one connect.sid with:

Domain   = 136c4c4b-…​.repl.co     (host-only)
Path     = /
Secure   = ✓
SameSite = Lax

3 · Add a guard log so this never sneaks back

app.use((req, _res, next) => {
  const c = req.headers.cookie || '';
  const dupes = (c.match(/connect\.sid=/g) || []).length;
  if (dupes > 1) {
    console.warn('⚠️  Multiple connect.sid cookies detected:', c);
  }
  next();
});

If someone re-introduces a second cookie, you’ll see it instantly in the server logs.
Quick test cycle

    Clear site data.

    Hot-reload server with the single-session-middleware config.

    Login.

    DevTools → Cookies: you should see one row.

    Navigate to /api/auth/me in the browser → 200 OK with your user object.

    Refresh the SPA – it should go straight to the portal, no loop.

Once this passes, re-enable your 5-second AbortController timeout; it shouldn’t fire anymore because /me will resolve well under that window.

That should lock this class of bug down for good.
